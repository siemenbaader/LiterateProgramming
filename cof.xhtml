<?xml version='1.0' encoding='UTF-8'?>
<html xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <title> The Javascript Consistent Object Framework </title>
    <script src="helpers.js"/> 
    <script src='showdown.js'/>
    <script src='coffee-script.js'/>
    <coffee-script><![CDATA[

      Function.prototype.args = ->
        '''
          String representation of arguments for this function.
        '''
        @toString().match( /\(([^)]*)\)/ )[1]


      Function.prototype.doc_string = ->
        '''
          Raw doc string for this function or null if does not exists.
        '''
        matches = @toString().match( /^function\s+\w*\([^)]*\)\s+{\s+('(?:[^']|\\.)*');/ )
        matches and eval matches[1]


      Function.prototype.return_type = ->
        '''
          The return type for this function or null if unknown.
        '''
        null


      class @DocumentedObject

        doc_string: ->
          '''
            Hello, Object!
          '''

        constructor: ->
          '''
            Hello, Class!
          '''

        class: ->
          @constructor.name


       class @Foo extends DocumentedObject

    ]]></coffee-script>
  </head>
  <body>

    <style> 
      body { font-family: Helvetica; }
      .abstract { font-style: italic; padding-left: 5em; padding-right: 5em; display:block;}
      code { padding: .5em; font-weight: bold; margin-left: 2em; display: block; border: 1px solid #ccc; background-color: #eee; white-space: pre-wrap; }
      code[type] { border: 1px solid blue; background-color: #DDF; -webkit-transition: border-color 1s ease-out, background-color 1s ease-out; }
      code.pass { border: 1px solid green; background-color: #AFA; }
      code.fail { border: 1px solid red; background-color: #FAA; }
      code.exception { border: 5px solid red; background-color: #FAA; }
      div.exception { border: 2px solid red; background-color: white; padding: 1em; margin-top: .5em; }
    </style>
<source><![CDATA[
#Dynamic Inspection and On-Line API Documentation for JavaScript
#### Bjarke Walling <bwp@bwp.dk> and Siemen Baader <siemenbaader@gmail.com>
]]></source>

<source class="abstract"><![CDATA[
Interactive consoles - or Read Eval Print Loops (REPLs) - are a central in software development with dynamic languages. They allow programmers to rapidly interact with objects and functions and learn how they behave. REPLs are used to quickly explore new ideas, as well as for debugging.

The Ruby REPL provides a powerful and concise view to inspect objects and their fields. Likewise, Python's REPL allows access to API documentation as direct properties of objects. These are important usability features for this way of programming, because these aspects are important information for reasoning about the objects under concern. Providing them in-situ, in the REPL, allows the programmer very direct access to them and reduces the need to use inspection tools or external documentation. Unfortunately, the JavaScript runtimes today do not provide this livel of inspection and on-line documentation.

In this dynamic paper, we have made use of a Literate Programming approach to develop an inspection framework for JavaScript. The framework allows dynamic inspection, and access to API documentation. 

]]></source>

<source><![CDATA[

Outline
-------


* functions
  - docstring
  - signature & type
  - return type
  - args string
  
* object inspection
  - irb: fields.
  - closure-bound... : @inspections[]

* return types and callbacks


* sugar
  - documented object
  - neat syntax / 
  
* graceful callbacks

Functions
---------
Raw Data:


    Existing:
      node: > require
    { [Function: require]
      resolve: [Function],
      paths: 
      [ '/home/siemen/.node_modules',
        '/home/siemen/.node_libraries',
        '/usr/local/lib/node' ],
      main: undefined,
      extensions: { '.js': [Function], '.node': [Function] },
      registerExtension: [Function],
      cache: {} }
    > require.toString()
    'function require(path) {\n    return Module._load(path, self);\n  }'
    > 
    chrome: alert
    function alert() { [native code] }
    get
    function get(url) {
      return blocking_ajax_request(url, "get");
    }

    ruby:
    >> a = lambda {|i| i * 9}
    => #<Proc:0xb76a32d8@(irb):1>

    >> Foo.new.methods
    => ["to_yaml", "taguri", "inspect", "tap", "clone", "poc", "taguri=", "public_methods", "__send__", "object_id", "instance_variable_defined?", "equal?", "freeze", "extend", "send", "methods", "to_yaml_style", "hash", "dup", "to_enum", "instance_variables", "eql?", "instance_eval", "id", "singleton_methods", "taint", "ri", "ar", "enum_for", "frozen?", "instance_variable_get", "instance_of?", "display", "to_a", "method", "pretty_print_inspect", "type", "instance_exec", "protected_methods", "==", "===", "instance_variable_set", "kind_of?", "respond_to?", "pretty_print_cycle", "to_s", "class", "po", "private_methods", "=~", "tainted?", "__id__", "untaint", "nil?", "pretty_print_instance_variables", "to_yaml_properties", "pretty_inspect", "is_a?", "pretty_print"]
    >> Foo.new.inspect
    => "#<Foo:0xb7612f1c>"



#important:

- arguments: names, types, arity, splat
- doc
- return types & callback signatures


<code type='text/coffeescript'>
((a, b) -> a + b).args() == 'a, b'
</code>


]]></source>


    <script><![CDATA[
      var renderMarkdown = function() {

        var showdown = new Showdown.converter();

        var sources = document.getElementsByTagName("source");
        sources.forEach( function(src) {
          var t = src.textContent;
          var html = showdown.makeHtml(t);

          // Remove first empty line of code blocks.
          html = html.replace( /(<code[^>]*>)\n/ , "$1");

          src.innerHTML = html;
        }) 
      }

      var testCodeExamples = function() {
        var examples = document.getElementsByTagName("code");
        examples.forEach( function(ex) {
          var code = ex.textContent;
          if (ex.getAttribute('type') === 'text/coffeescript') {
            try {
              var outcome = CoffeeScript.eval(code, {bare: 'on'});
            }
            catch(e) {
              ex.setAttribute("class", "exception");
              l(e)
              ex.appendChild(Node("div", {class: "exception"}, [e.toString(), ". Sorry, try REPL ..."] ))
              l(code);
            }
            ex.setAttribute("class", (outcome) ? "pass": "fail")
          }
        })
      };

      var loadCoffeeScripts = function() {
        var scripts = document.getElementsByTagName("coffee-script");
        scripts.forEach( function(script) {
          CoffeeScript.run(script.textContent);
        });
      };

      loadCoffeeScripts();
      renderMarkdown();
      testCodeExamples();


    ]]></script>

  </body>
</html>
