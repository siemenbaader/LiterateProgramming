<?xml version='1.0' encoding='UTF-8'?>
<html xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <title> The Javascript Consistent Object Framework </title>
    <script src="helpers.js"/> 
    <script src='showdown.js'/>
    <script src='coffee-script.js'/>
    <coffee-script><![CDATA[

      Function.prototype.raw_doc = ->
        '''
          Raw doc string for this function or null if does not exists.
        '''
        matches = @toString().match /^function\s+\w*\([^)]*\)\s+{\s+('(?:[^']|\\.)*');/
        matches and (eval matches[1]).replace /\r\n?/g, '\n'


      Function.prototype.doc_signature = ->
        '''
          Signature declared in the doc string of this function or null.
        '''
        (@raw_doc() or '').match /^[ \t]*(?:\((.*)\))?[ \t]*->(.*)(?:\n|$)/


      Function.prototype.doc = ->
        '''
          Documentation for this function or null if does not exists.
        '''
        doc = @raw_doc()
        return null unless doc
        doc = doc.replace /^.+(?:\n|$)/ , '' if @doc_signature()?
        doc = doc.replace /^(?:[ \t]*\n)*/ , ''  # Trim empty lines in beginning
        doc = doc.replace /(?:\n[ \t]*)*$/ , ''  # Trim empty lines in end
        return doc


      Function.prototype.args = ->
        '''
          String representation of arguments for this function.
        '''
        signature = @doc_signature()
        if signature? and signature[1]?
          signature[1]
        else
          @toString().match( /\(([^)]*)\)/ )[1]


      Function.prototype.return_type = ->
        '''
          The return type for this function or null if unknown. Default null.
        '''
        signature = @doc_signature()
        if signature?
          type = signature[2].trim()
          return type if type
        return null


      Function.prototype.inspect = ->
        '''
          Inspects a function.
        '''
        text = "(#{ @args() }) -> #{ @return_type() or 'return-type-not-documented' }"
        if @doc()?
          text += ('\n' + @doc()).replace /\n/g, '\n  '
        return text


      Math.sqrt.raw_doc = -> '''
        (value : Number) -> Number

        Square root of a number. If value is a negative number, NaN is returned.
      '''


      class @DocumentedObject

        doc_string: ->
          '''
            Hello, Object!
          '''

        constructor: ->
          '''
            Hello, Class!
          '''

        class: ->
          @constructor.name


       class @Foo extends DocumentedObject

    ]]></coffee-script>
  </head>
  <body>

    <style> 
      body { font-family: Helvetica; }
      .abstract { font-style: italic; padding-left: 5em; padding-right: 5em; display:block;}
      code { padding: .5em; font-weight: bold; margin-left: 2em; display: block; border: 1px solid #ccc; background-color: #eee; white-space: pre-wrap; }
      code[type] { border: 1px solid blue; background-color: #DDF; -webkit-transition: border-color 1s ease-out, background-color 1s ease-out; }
      code.pass { border: 1px solid green; background-color: #AFA; }
      code.fail { border: 1px solid red; background-color: #FAA; }
      code.exception { border: 5px solid red; background-color: #FAA; }
      div.exception { border: 2px solid red; background-color: white; padding: 1em; margin-top: .5em; }
    </style>
<source><![CDATA[
#Dynamic Inspection and On-Line API Documentation for JavaScript
#### Bjarke Walling <bwp@bwp.dk> and Siemen Baader <siemenbaader@gmail.com>
]]></source>

<source class="abstract"><![CDATA[
Interactive consoles - or Read Eval Print Loops (REPLs) - are a central in software development with dynamic languages. They allow programmers to rapidly interact with objects and functions and learn how they behave. REPLs are used to quickly explore new ideas, as well as for debugging.

The Ruby REPL provides a powerful and concise view to inspect objects and their fields. Likewise, Python's REPL allows access to API documentation as direct properties of objects. These are important usability features for this way of programming, because these aspects are important information for reasoning about the objects under concern. Providing them in-situ, in the REPL, allows the programmer very direct access to them and reduces the need to use inspection tools or external documentation. Unfortunately, the JavaScript runtimes today do not provide this livel of inspection and on-line documentation.

In this dynamic paper, we have made use of a Literate Programming approach to develop an inspection framework for JavaScript. The framework allows dynamic inspection, and access to API documentation. 

]]></source>

<source><![CDATA[

Outline
-------


* functions
  - docstring
  - signature & type
  - return type
  - args string
  
* object inspection
  - irb: fields.
  - closure-bound... : @inspections[]

* return types and callbacks


* sugar
  - documented object
  - neat syntax / 
  
* graceful callbacks

Functions
---------
Raw Data:


    Existing:
      node: > require
    { [Function: require]
      resolve: [Function],
      paths: 
      [ '/home/siemen/.node_modules',
        '/home/siemen/.node_libraries',
        '/usr/local/lib/node' ],
      main: undefined,
      extensions: { '.js': [Function], '.node': [Function] },
      registerExtension: [Function],
      cache: {} }
    > require.toString()
    'function require(path) {\n    return Module._load(path, self);\n  }'
    > 
    chrome: alert
    function alert() { [native code] }
    get
    function get(url) {
      return blocking_ajax_request(url, "get");
    }

    ruby:
    >> a = lambda {|i| i * 9}
    => #<Proc:0xb76a32d8@(irb):1>

    >> Foo.new.methods
    => ["to_yaml", "taguri", "inspect", "tap", "clone", "poc", "taguri=", "public_methods", "__send__", "object_id", "instance_variable_defined?", "equal?", "freeze", "extend", "send", "methods", "to_yaml_style", "hash", "dup", "to_enum", "instance_variables", "eql?", "instance_eval", "id", "singleton_methods", "taint", "ri", "ar", "enum_for", "frozen?", "instance_variable_get", "instance_of?", "display", "to_a", "method", "pretty_print_inspect", "type", "instance_exec", "protected_methods", "==", "===", "instance_variable_set", "kind_of?", "respond_to?", "pretty_print_cycle", "to_s", "class", "po", "private_methods", "=~", "tainted?", "__id__", "untaint", "nil?", "pretty_print_instance_variables", "to_yaml_properties", "pretty_inspect", "is_a?", "pretty_print"]
    >> Foo.new.inspect
    => "#<Foo:0xb7612f1c>"



#important:

- arguments: names, types, arity, splat
- doc
- return types & callback signatures



CoffeeScript implementation
===========================


### Arguments

You can query functions for their arguments:

<code type='text/coffeescript'>
( (a, b) -> a + b ).args() == 'a, b'
</code>

And some functions declare more specific argument usage:

<code type='text/coffeescript'>
Math.sqrt.args() == 'value : Number'
</code>

You can declare arguments usage yourself:

<code type='text/coffeescript'>
( (a, b) ->
    ''' (a : Number, b : Number) -> Number '''
    a + b
).args() == 'a : Number, b : Number'
</code>


### Return type

Default the return type is unknown:

<code type='text/coffeescript'>
( (a, b) -> a + b ).return_type() == null
</code>

Some functions have their return type declared:

<code type='text/coffeescript'>
Math.sqrt.return_type() == 'Number'
</code>

You can declare return types yourself:

<code type='text/coffeescript'>
( (a, b) ->
    ''' (a : Number, b : Number) -> Number '''
    a + b
).return_type() == 'Number'
</code>

Or if you only want to declare the return type:

<code type='text/coffeescript'>
( (a, b) ->
    ''' -> Number '''
    a + b
).return_type() == 'Number'
</code>


### Inline documentation

Default functions are not documented:

<code type='text/coffeescript'>
( (a, b) -> a + b ).doc() == null
</code>

But they can be documented:

<code type='text/coffeescript'>
( (a, b) ->
    '''
      (a : Number, b : Number) -> Number
      The sum of two numbers. If either a or b is NaN, NaN is returned.
    '''
    a + b
).doc() == 'The sum of two numbers. If either a or b is NaN, NaN is returned.'
</code>


### Inspection

Functions can be inspected:

<code type='text/coffeescript'>
( (a, b) -> a + b ).inspect() == '(a, b) -> return-type-not-documented'
</code>

If arguments and return types are declared and inline documentation is added,
a more detailed inspection is provided:

<code type='text/coffeescript'>
Math.sqrt.inspect() == '''
  (value : Number) -> Number
    Square root of a number. If value is a negative number, NaN is returned.
'''
</code>


]]></source>


    <script><![CDATA[
      var renderMarkdown = function() {

        var showdown = new Showdown.converter();

        var sources = document.getElementsByTagName("source");
        sources.forEach( function(src) {
          var t = src.textContent;
          var html = showdown.makeHtml(t);

          // Remove first empty line of code blocks.
          html = html.replace( /(<code[^>]*>)\n/g , "$1");

          src.innerHTML = html;
        }) 
      }

      var testCodeExamples = function() {
        var examples = document.getElementsByTagName("code");
        examples.forEach( function(ex) {
          var code = ex.textContent;
          if (ex.getAttribute('type') === 'text/coffeescript') {
            try {
              var outcome = CoffeeScript.eval(code, {bare: 'on'});
            }
            catch(e) {
              ex.setAttribute("class", "exception");
              l(e)
              ex.appendChild(Node("div", {class: "exception"}, [e.toString(), ". Sorry, try REPL ..."] ))
              l(code);
            }
            ex.setAttribute("class", (outcome) ? "pass": "fail")
          }
        })
      };

      var loadCoffeeScripts = function() {
        var scripts = document.getElementsByTagName("coffee-script");
        scripts.forEach( function(script) {
          CoffeeScript.run(script.textContent);
        });
      };

      loadCoffeeScripts();
      renderMarkdown();
      testCodeExamples();


    ]]></script>

  </body>
</html>
